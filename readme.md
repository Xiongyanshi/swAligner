swAligner
> Smith-Waterman Alignment program.

# Usage
## Getting start
```
# quick help
python swAligner.py -h

# run demo
python swAligner.py

# input sequences from file
python swAligner.py -i demo/input1.fa

# input sequences from copy and paste
python swAligner.py -r atactttcg,acccttttcgaa

# write aligned reads into file
python swAligner.py -i demo/input2.fa -o input2.aligned.fa

# use another base substitution matrix
python swAligner.py -i demo/input2.fa -m lib/dna_sub1.mat

# use another gap penalty
python swAligner.py -i demo/input2.fa -g lib/dna_gap.2.txt

# use Needleman-Wunsch global alignment (default is Smith-Waterman local alignment)
python swAligner.py -i demo/input2.fa -a nw

```
## Advanced usage
### Prepare and implement your own substitution matrix (-m)
substitution matrix is a tab delimited table, first character of first row doesn't matter, only int will be accepted (default, lib/dna_sub.default.mat):
```
\	a	t	c	g
a	3	-3	-3	-3
t	-3	3	-3	-3
c	-3	-3	3	-3
g	-3	-3	-3	3
```
For instance, if you prefer more similarity between purines or pyrimidines, you may wanna use this one (lib/dna_sub.1.mat) :
```
\	a	t	c	g
a	3	-3	-3	1
t	-3	3	1	-3
c	-3	1	3	-3
g	1	-3	-3	3
```
### Another gap penalty scheme (-g)
Default gap penalty configuration file is "lib/dna_gap.default.txt" :
```
open=0
extend=-2
```
This means opening a gap will cost nothing, and extending a gap will -2. In other words, there is no difference between opening a gap and extending a gap. As such, "-" match to "A" means -2, "---" match to "ACG" means -2*3 = -6.

But, you may prefer opening a gap cost much more than extending a gap, this will make alignment program trying to find continuous body, for example in lib/dna_gap.1.txt:
```
open=-5
extend=-2
```
In this way, "-" match to "A" means -5 + -2*1 =-7, "---" match to "ACG" means -5 + -2*3 = -11.

For example:
```
$ python swAligner.py  -i demo/input2.fa -g lib/dna_gap.default.txt

TACGGGCCCGCTAC------
|| |  | | |||
TA-G--C-C-CTATCGGTCA

$ python swAligner.py  -i demo/input2.fa -g lib/dna_gap.1.txt

TACGGGCCCGCTAC------
     || | |||
---TAGC-C-CTATCGGTCA

```
### Not Smith-Waterman, try Needleman-Wunsch (-a)
Smith-Waterman local alignment is the default algorithm, but Needleman-Wunsch global alignment is also supported. You can use -a parameter to specify it, -a only accept 'nw' or 'sw'.
For instance:
```
$ python swAligner.py -i demo/input2.fa -a sw

TACGGGCCCGCTAC----
     ||||
---TAGCCCTATCGGTCA

$ python swAligner.py -i demo/input2.fa -a nw

TACGGGC-C-CGCTAC-
|| |**| * ||*| |
TA-GCCCTATCGGT-CA

```
# Algorithm
## How it works
The Smith-Waterman algorithm performs local sequence alignment, a derived version of Needleman-Wunsch algorithm. Based on match/mismatch/gap penalty scheme, a m*n matrix is iteratively generated and followed by tracing back from the highest score cell to zero cell. Practically, two m*n numpy 2d array(matrix) is constructed: "scoremat", a matrix of the scores calculated, and "tracemat", a matrix of which way the value in scoremat is caculated. The alignment solution is generated by the tracing back the direction in "tracemat", and represented in "pathcode". The match/mismatch score (substitution matrix) and gap penally are both configurable.

## Scheme design
"lib/seqio.py" is responsible for parsing sequence records from fasta, and only first two records will be read. In seqio.py, class "Fasta" could read sequence records from file or string if specified, by using Fasta('filename.fa') or Fasta('>seq1\nattccg\n>seq2\nactg\n'). If nothing provided to Fasta when you first call it, like just fas = Fasta(), it's fine, you can make it rich by using "fas.from_string('>seq1\nattccg\n>seq2\nactg\n')". In details, Fasta.from_string() is the working horse of class Fasta(). This is designed for building output fasta object, of which sequences is generated from alignment engine.

"lib/readmat.p" is responsible for parsing substutution matrix from file. The function readmat() will parse substitution matrix file and return a 2-layer nested dict.

"lib/readgap.py" is responsible for parsing gap open and extend penalty scheme from file. The function readgap() will return a dict with two fixed kyes, 'gap_open' and 'gap_extend'.

"swAligner.py". Class 'Align' is the core of this alignment program. It's responsible for making score matrix, tracing back, and formatting printable alignment result.

## Module required
```
re, numpy, argparse
```

